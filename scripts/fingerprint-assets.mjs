#!/usr/bin/env node

import { createHash } from "crypto";
import { promises as fs } from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, "..");
const publicDir = path.join(projectRoot, "public");
const fingerprintRoot = path.join(publicDir, "assets-fingerprint");
const headersPath = path.join(publicDir, "_headers");
const generatedDir = path.join(projectRoot, "src", "generated");
const manifestPath = path.join(generatedDir, "asset-manifest.json");
const metricsPath = path.join(projectRoot, "cache-metrics.json");

const IGNORED_DIRECTORIES = new Set(["assets-fingerprint"]);
const IGNORED_FILES = new Set(["_headers"]);

async function rmDir(targetPath) {
  await fs.rm(targetPath, { recursive: true, force: true });
}

async function ensureDir(targetPath) {
  await fs.mkdir(targetPath, { recursive: true });
}

async function collectAssets(dir) {
  const dirents = await fs.readdir(dir, { withFileTypes: true });
  const assets = [];

  for (const dirent of dirents) {
    const name = dirent.name;
    if (dirent.isDirectory()) {
      if (IGNORED_DIRECTORIES.has(name)) {
        continue;
      }

      const nested = await collectAssets(path.join(dir, name));
      assets.push(...nested);
      continue;
    }

    if (IGNORED_FILES.has(name)) {
      continue;
    }

    const absolutePath = path.join(dir, name);
    const relativePath = path.relative(publicDir, absolutePath);
    assets.push({ absolutePath, relativePath });
  }

  return assets;
}

function createHashArtifacts(buffer) {
  const hash = createHash("sha256");
  hash.update(buffer);
  const digestHex = hash.digest("hex");
  const digestBase64 = Buffer.from(digestHex, "hex").toString("base64");
  return {
    digestHex,
    digestBase64,
    shortHash: digestHex.slice(0, 12),
  };
}

function toPosix(p) {
  return p.split(path.sep).join(path.posix.sep);
}

async function writeManifest(entries) {
  await ensureDir(generatedDir);
  const sorted = entries.sort((a, b) => a.logical.localeCompare(b.logical));
  const manifestObject = {};

  for (const entry of sorted) {
    manifestObject[entry.logical] = {
      path: entry.fingerprinted,
      integrity: `sha256-${entry.digestBase64}`,
      sha256: entry.digestHex,
    };
  }

  const manifestJson = JSON.stringify(manifestObject, null, 2) + "\n";
  await fs.writeFile(manifestPath, manifestJson, "utf8");
}

async function writeHeaders(entries) {
  if (entries.length === 0) {
    await fs.rm(headersPath, { force: true });
    return;
  }

  const lines = [
    "# Auto-generated by scripts/fingerprint-assets.mjs",
    "# Do not edit manually.",
  ];

  const sorted = entries
    .slice()
    .sort((a, b) => a.fingerprinted.localeCompare(b.fingerprinted));

  for (const entry of sorted) {
    lines.push(entry.fingerprinted);
    lines.push("  Cache-Control: public,max-age=31536000,immutable");
    lines.push(`  ETag: "sha256-${entry.digestBase64}"`);
  }

  lines.push("");
  await fs.writeFile(headersPath, lines.join("\n"), "utf8");
}

async function copyFingerprintedAssets(assets) {
  await rmDir(fingerprintRoot);
  await ensureDir(fingerprintRoot);

  const entries = [];

  for (const asset of assets) {
    const buffer = await fs.readFile(asset.absolutePath);
    const { digestHex, digestBase64, shortHash } = createHashArtifacts(buffer);
    const parsed = path.parse(asset.relativePath);
    const hashedFileName = `${parsed.name}.${shortHash}${parsed.ext}`;
    const fingerprintedRelative = path.join(parsed.dir, hashedFileName);
    const targetPath = path.join(fingerprintRoot, fingerprintedRelative);

    await ensureDir(path.dirname(targetPath));
    await fs.writeFile(targetPath, buffer);

    const logical = `/${toPosix(asset.relativePath)}`;
    const fingerprinted = `/assets-fingerprint/${toPosix(
      fingerprintedRelative,
    )}`;

    entries.push({
      logical,
      fingerprinted,
      digestHex,
      digestBase64,
      bytes: buffer.byteLength,
    });
  }

  return entries;
}

async function writeCacheMetrics(entries) {
  const totalBytes = entries.reduce((sum, entry) => sum + entry.bytes, 0);
  const averageBytes =
    entries.length === 0 ? 0 : Math.round((totalBytes / entries.length) * 100) / 100;
  const assets = entries
    .slice()
    .sort((a, b) => a.fingerprinted.localeCompare(b.fingerprinted))
    .map((entry) => ({
      logical: entry.logical,
      fingerprinted: entry.fingerprinted,
      bytes: entry.bytes,
    }));

  const metrics = {
    generatedAt: new Date().toISOString(),
    assetCount: entries.length,
    totalBytes,
    averageBytes,
    assets,
  };

  await fs.writeFile(metricsPath, JSON.stringify(metrics, null, 2) + "\n", "utf8");
}

async function main() {
  const assets = await collectAssets(publicDir);
  const entries = await copyFingerprintedAssets(assets);
  await writeManifest(entries);
  await writeHeaders(entries);
  await writeCacheMetrics(entries);
  console.log(
    `Fingerprinting complete: ${entries.length} assets processed.`,
  );
}

main().catch((error) => {
  console.error("[fingerprint-assets] Failed:", error);
  process.exitCode = 1;
});
